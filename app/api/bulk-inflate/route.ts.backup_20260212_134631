import { createClient } from '@supabase/supabase-js'
import { NextRequest } from 'next/server'

export const dynamic = 'force-dynamic'
export const maxDuration = 60

export async function POST(req: NextRequest) {
  console.log(' [BULK-INFLATE-V2] Démarrage injection')
  const startTime = Date.now()

  try {
    const modules = await req.json()
    console.log(` [BULK-INFLATE-V2] ${modules.length} modules reçus`)

    const url = process.env.NEXT_PUBLIC_SUPABASE_URL
    const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY

    if (!url || !serviceKey) {
      console.error(' Configuration Supabase manquante')
      return Response.json({
        success: false,
        error: 'Variables SUPABASE manquantes'
      }, { status: 500 })
    }

    const supabase = createClient(url, serviceKey, {
      auth: { persistSession: false }
    })

    //  NETTOYER curriculum_density et autres colonnes non-standard
    const cleanedModules = modules.map((m: any) => {
      const {
        curriculum_density,  //  Retirer
        ...validFields
      } = m
      return validFields
    })

    console.log(` [BULK-INFLATE-V2] Modules nettoyés (curriculum_density retiré)`)

    // Insertion par batch de 20
    const batchSize = 20
    let inserted = 0
    let failed = 0
    const batchErrors: any[] = []

    for (let i = 0; i < cleanedModules.length; i += batchSize) {
      const batch = cleanedModules.slice(i, i + batchSize)
      const batchNum = Math.floor(i / batchSize) + 1
      const totalBatches = Math.ceil(cleanedModules.length / batchSize)
      
      console.log(` [BULK-INFLATE-V2] Batch ${batchNum}/${totalBatches} (${batch.length} modules)`)
      
      const { data, error } = await supabase
        .from('modules')
        .insert(batch)
        .select('id')

      if (error) {
        console.error(` [BULK-INFLATE-V2] Erreur batch ${batchNum}:`, error.message, error.code)
        failed += batch.length
        batchErrors.push({
          batch: batchNum,
          error: error.message,
          code: error.code
        })
      } else {
        inserted += data?.length || batch.length
        console.log(` [BULK-INFLATE-V2] Batch ${batchNum} OK (${data?.length || batch.length} modules)`)
      }
    }

    // Compter le total final
    const { count: totalCount } = await supabase
      .from('modules')
      .select('id', { count: 'exact', head: true })

    const duration = `${Date.now() - startTime}ms`
    console.log(` [BULK-INFLATE-V2] Terminé en ${duration}`)
    console.log(` Résumé : ${inserted} insérés, ${failed} échecs, ${totalCount} total DB`)

    return Response.json({
      success: true,
      summary: {
        received: modules.length,
        inserted,
        failed,
        totalInDatabase: totalCount || 0,
        duration,
        batches: Math.ceil(modules.length / batchSize),
        batchErrors: batchErrors.length > 0 ? batchErrors : undefined
      }
    })

  } catch (error: any) {
    console.error(' [BULK-INFLATE-V2] Exception:', error.message)
    return Response.json({
      success: false,
      error: error.message,
      code: error.code
    }, { status: 500 })
  }
}